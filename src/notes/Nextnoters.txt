key features of next
Server-Side Rendering (SSR):   Next.js enables server-side rendering out of the box. This means that pages 
can be pre-rendered on the server before being sent to the client. SSR improves initial page load performance 
and enables search engines to crawl and index the content effectively. It also provides a better experience for 
users with slower internet connections.

File-based Routing: Next.js introduces a file-based routing system. You can create a new file under the pages
 directory,and Next.js will automatically map it to a corresponding route. 

 Static Site Generation (SSG): Next.js supports static site generation, allowing you to pre-render entire pages 
 at build time. This is useful for content that doesn't frequently change, such as blog posts or documentation.
  With SSG, you can generate HTML files for each page in advance, resulting in faster page loads and better SEO
   performance.

Built-in CSS Support: Next.js provides built-in support for styling components using CSS. 

when should i call api in getServerSideProps

You should call an API inside the getServerSideProps function in Next.js when you need to fetch data that is 
specific to each request and cannot be pre-rendered at build time. Here are some scenarios where using 
getServerSideProps for API calls is appropriate:

Dynamic Data: If the data you need to fetch depends on dynamic parameters or user-specific information 
(e.g., user authentication, session data, or query parameters), getServerSideProps allows you to fetch the data
 dynamically on each request.

Personalized Content: When you have content that needs to be personalized for each user, such as user-specific 
dashboard information or personalized recommendations, getServerSideProps can fetch the necessary data based on 
the user's session or authentication information.

Real-Time Data: If you have data that frequently changes and needs to be up-to-date for each request, 
getServerSideProps enables you to fetch the latest data from an API on the server-side, ensuring that the rendered 
page always reflects the most recent information.

Data with Server-Side Logic: Sometimes, you may need to perform server-side calculations, transformations, 
or business logic before rendering the page. getServerSideProps allows you to fetch the required data and process 
it on the server before rendering the page.

Not calling an API in getServerSideProps can be suitable for cases where:

The data is not required for the initial page load and can be fetched asynchronously on the client-side after the page has rendered.

The data is not essential for search engine optimization (SEO) or doesn't need to be pre-rendered for better performance or content visibility.

You want to offload the API call from the server-side rendering process to reduce server load or minimize the time needed to generate the initial page.


import React from 'react';

function HomePage({ serverRenderedData }) {
  return (
      <p>Server-rendered data: {serverRenderedData}</p>
  );
}

export async function getServerSideProps() {
  // Call an API to fetch data
  const response = await fetch('https://api.example.com/data');
  const data = await response.json();

  // Extract the relevant data from the API response
  const serverRenderedData = data.someKey;

  // Return the data as props
  return {
    props: {
      serverRenderedData
    }
  };
}

export default HomePage;

const AboutUsComponent = dynamic(() => import('../../Container/AboutUS'), {
  suspense: true,
});

Dynamic importing in Next.js allows you to import components or modules dynamically at runtime, instead of
 including them in the initial bundle. This can help reduce the bundle size and improve performance by loading the
  necessary code only when it's actually needed.

  suspense: true, :This enables the usage of Suspense to handle the loading state while the component is being loaded
  providing a better user experience during the component loading process.

  
next js supports file based routing 

   server coponent : a component which execute on server its fater and best for seo on server side ui is coming 
   from server 
   clent component : a component which excecute on browser on client 

   on compolex application we should use next js  
    default type of componet is sever component
     
     if we want to create client component we have to use "use client" on number one line other wise we get error

     # we cant use events in server components like onclick 

     why server component better for seo 
     serch engine can easily read page content from server rendering

     #there are two tehniques 
     for pre rendering 
     1 static side genration and  serverside randerig ehich we can do with getStaticProps() and getserverSideprops()

     through both these we can pre rander pages which means our html our data will go to client randered
     before hand  
    
getstaticpath=>specify  dynamic route to pre rander pages 
     getStaticPaths must be used with getStaticProps
You cannot use getStaticPaths with getServerSideProps

lasy loding in react
import React, { Suspense } from 'react';
const LazyComponent = React.lazy(() => import('./LazyComponent'));
function MyComponent() {
  return (
    <Suspense fallback={<div>Loading...</div>}>
      <LazyComponent />
    </Suspense>
  );
}

//next 
const ContactUs = dynamic(() => import('../../Container/ContactUs'), {
  suspense: true,
  loading: () => <p>Loading...</p>,
});
//promis
const myPromise = new Promise((resolve, reject) => {
  // Asynchronous operation
  setTimeout(() => {
    // If the operation is successful, call resolve
    resolve('Operation completed successfully');

    // If there's an error, call reject
    // reject('Operation failed');
  }, 2000);
});
then(onFulfilled, onRejected): Attaches callbacks for handling the fulfillment or rejection of the Promise.
catch(onRejected): Attaches a callback to handle the rejection of the Promise. It's equivalent to .then(null, onRejected).
finally(onFinally): Attaches a callback to execute regardless of whether the Promise is fulfilled or rejected. It's useful for cleanup operations.
Promise.resolve(value): Creates a resolved Promise with the specified value.
Promise.reject(reason): Creates a rejected Promise with the specified reason.
Promise.all(iterable): Returns a single Promise that resolves when all of the promises in the iterable argument have resolved or when the iterable contains no promises.
Promise.race(iterable): Returns a Promise that resolves or rejects as soon as one of the promises in the iterable resolves or rejects, with the value or reason from that promise.
states of promis
 Pending: Initial state, neither fulfilled nor rejected.
Fulfilled: The operation completed successfully.
Rejected: The operation failed