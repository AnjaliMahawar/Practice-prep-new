
Next.js is a React-based framework for building full-stack web applications with features like:
Server-side rendering
Static site generation
API routes
File-based routing
Image optimization
Middleware
Incremental static regeneration (ISR)
Built-in support for SEO

key features of next
Server-Side Rendering (SSR):   Next.js enables server-side rendering out of the box. This means that pages 
can be pre-rendered on the server before being sent to the client. SSR improves initial page load performance 
and enables search engines to crawl and index the cgg
y
ntent effectively. It also provides a better experience for 
users with slower internet connections.

File-based Routing: Next.js introduces a file-based routing system. You can create a new file under the pages
 directory,and Next.js will automatically map it to a corresponding route. 

 Static Site Generation (SSG): Next.js supports static site generation, allowing you to pre-render entire pages 
 at build time. This is useful for content that doesn't frequently change, such as blog posts or documentation.
  With SSG, you can generate HTML files for each page in advance, resulting in faster page loads and better SEO
   performance.

Built-in CSS Support: Next.js provides built-in support for styling components using CSS. 

when should i call api in getServerSideProps

You should call an API inside the getServerSideProps function in Next.js when you need to fetch data that is 
specific to each request and cannot be pre-rendered at build time. Here are some scenarios where using 
getServerSideProps for API calls is appropriate:

Dynamic Data: If the data you need to fetch depends on dynamic parameters or user-specific information 
(e.g., user authentication, session data, or query parameters), getServerSideProps allows you to fetch the data
 dynamically on each request.

Personalized Content: When you have content that needs to be personalized for each user, such as user-specific 
dashboard information or personalized recommendations, getServerSideProps can fetch the necessary data based on 
the user's session or authentication information.

Real-Time Data: If you have data that frequently changes and needs to be up-to-date for each request, 
getServerSideProps enables you to fetch the latest data from an API on the server-side, ensuring that the rendered 
page always reflects the most recent information.

Data with Server-Side Logic: Sometimes, you may need to perform server-side calculations, transformations, 
or business logic before rendering the page. getServerSideProps allows you to fetch the required data and process 
it on the server before rendering the page.

Not calling an API in getServerSideProps can be suitable for cases where:

The data is not required for the initial page load and can be fetched asynchronously on the client-side after the page has rendered.

The data is not essential for search engine optimization (SEO) or doesn't need to be pre-rendered for better performance or content visibility.

You want to offload the API call from the server-side rendering process to reduce server load or minimize the time needed to generate the initial page.


import React from 'react';

function HomePage({ serverRenderedData }) {
  return (
      <p>Server-rendered data: {serverRenderedData}</p>
  );
}

export async function getServerSideProps() {
  // Call an API to fetch data
  const response = await fetch('https://api.example.com/data');
  const data = await response.json();

  // Extract the relevant data from the API response
  const serverRenderedData = data.someKey;

  // Return the data as props
  return {
    props: {
      serverRenderedData
    }
  };
}

export default HomePage;

const AboutUsComponent = dynamic(() => import('../../Container/AboutUS'), {
  suspense: true,
});

Dynamic importing in Next.js allows you to import components or modules dynamically at runtime, instead of
 including them in the initial bundle. This can help reduce the bundle size and improve performance by loading the
  necessary code only when it's actually needed.

  suspense: true, :This enables the usage of Suspense to handle the loading state while the component is being loaded
  providing a better user experience during the component loading process.

  
next js supports file based routing 

   server coponent : a component which execute on server its fater and best for seo on server side ui is coming 
   from server 
   clent component : a component which excecute on browser on client 

   on compolex application we should use next js  
    default type of componet is sever component
     
     if we want to create client component we have to use "use client" on number one line other wise we get error
     # we cant use events in server components like onclick 

     why server component better for seo 
     serch engine candsdx easily read page content from server rendering

     #there are two tehniques 
     for pre rendering 
     1 static side genration and  serverside randerig ehich we can do with getStaticProps() and getserverSideprops()

     through both these we can pre rander pages which means our html our data will go to client randered
     before hand  
    
getstaticpath=>specify  dynamic route to pre rander pages 
     getStaticPaths must be used with getStaticProps
You cannot use getStaticPaths with getServerSideProps

lasy loding in react
import React, { Suspense } from 'react';
const LazyComponent = React.lazy(() => import('./LazyComponent'));
function MyComponent() {
  return (
    <Suspense fallback={<div>Loading...</div>}>
      <LazyComponent />
    </Suspense>
  );
}

//next 
const ContactUs = dynamic(() => import('../../Container/ContactUs'), {
  suspense: true,
  loading: () => <p>Loading...</p>,
});
//promis
const myPromise = new Promise((resolve, reject) => {
  // Asynchronous operation
  setTimeout(() => {
    // If the operation is successful, call resolve
    resolve('Operation completed successfully');

    // If there's an error, call reject
    // reject('Operation failed');
  }, 2000);
});
then(onFulfilled, onRejected): Attaches callbacks for handling the fulfillment or rejection of the Promise.
catch(onRejected): Attaches a callback to handle the rejection of the Promise. It's equivalent to .then(null, onRejected).
finally(onFinally): Attaches a callback to execute regardless of whether the Promise is fulfilled or rejected. It's useful for cleanup operations.
Promise.resolve(value): Creates a resolved Promise with the specified value.
Promise.reject(reason): Creates a rejected Promise with the specified reason.
Promise.all(iterable): Returns a single Promise that resolves when all of the promises in the iterable argument have resolved or when the iterable contains no promises.
Promise.race(iterable): Returns a Promise that resolves or rejects as soon as one of the promises in the iterable resolves or rejects, with the value or reason from that promise.
states of promis
 Pending: Initial state, neither fulfilled nor rejected.
Fulfilled: The operation completed successfully.
Rejected: The operation failed

ISR ‚Äî Incremental Static Regeneration
ISR allows you to statically generate pages at build time and update them incrementally after deployment without rebuilding the entire site.
How It Works:
You define a revalidate period (in seconds) in your getStaticProps().

After the first request, a background regeneration is triggered if the page is older than the revalidation time.
export async function getStaticProps() {
  const data = await fetchData();
  return {
    props: { data },
    revalidate: 60, // Regenerate this page every 60 seconds
  };
}
Use Cases:
Blog posts
Product listings
Marketing pages with frequent updates
Pages where data changes, but not per user

üü¢ Pros:
Fast page loads (served from CDN)
Always up-to-date (after a small delay)
No rebuilds needed for content changes

CSR ‚Äî Client-Side Rendering
CSR renders content entirely in the browser after the page loads, typically using useEffect or other hooks to fetch data.
Goal	Choose
Fast, SEO-friendly page	ISR
Authenticated dashboard	CSR
Blog that updates weekly	ISR
Live analytics dashboard	csr

The /pages directory is the traditional file-based routing system in Next.js (before version 13). It maps files to routes automatically.
File-based routing
Pre-rendering using:
getStaticProps (SSG)

getServerSideProps (SSR)

getStaticPaths (for dynamic SSG routes)

Client-side navigation with next/link and next/router

API routes via pages/api/
Limitations
Difficult to manage layouts
No support for server components
Less control over rendering granularity
Lacks streaming and nested routing

The /app directory is a new, more powerful routing system based on React Server Components and layouts. It enables more advanced use cases.
Built on React Server Components (RSC)
Supports:
Nested layouts
Streaming (<Suspense>)
Server & client components
Loading & error UI
Built-in support for metadata (SEO)
/app
  layout.tsx              ‚Üí Defines root layout
  page.tsx                ‚Üí Home: '/'
  about/page.tsx          ‚Üí '/about'
  blog/[slug]/page.tsx    ‚Üí '/blog/my-post'
  blog/[slug]/loading.tsx ‚Üí Loading UI
  blog/[slug]/error.tsx   ‚Üí Error boundary

  Server-first by default (better performance)
Layouts that persist across routes
Advanced routing: parallel routes, intercepting routes
Built-in loading.tsx and error.tsx support
Streaming: only send what‚Äôs needed
What Is "Layout Support" in Next.js?
A layout is a common UI wrapper shared across multiple pages of your application ‚Äî for example:
A navbar,A footer,A sidebar,Shared CSS styles,Authentication wrapper
Instead of repeating that code on every page, a layout lets you define it once and reuse it across pages.
/app
  layout.tsx           ‚Üê Main layout (header/footer)
/app/dashboard
  layout.tsx           ‚Üê Dashboard-specific layout (sidebar)
/app/dashboard/page.tsx ‚Üê Dashboard page content
Each layout.tsx wraps only the routes below it. That means:

You can have nested layouts (e.g., a sidebar only on the dashboard)

Layouts persist across route changes without re-rendering

Layouts can be server or client components
In the old /pages directory (Pages Router), you used:

Function	Purpose
getStaticProps	Static Site Generation (SSG)
getServerSideProps	Server-Side Rendering (SSR)
getStaticPaths	Required for dynamic SSG routes with params
But in the new /app directory (App Router), these are replaced with React Server Components and fetch() caching strategies.
Old Pages Router	New App Router Replacement
getStaticProps	fetch() with { cache: 'force-cache' }
getServerSideProps	fetch() with { cache: 'no-store' }
getStaticPaths	generateStaticParams() function

Apollo Client helps your app send queries and mutations to a GraphQL server and store/cache the results efficiently.
Think of it as:
‚úîÔ∏è A tool to fetch data
‚úîÔ∏è A tool to update data
‚úîÔ∏è A tool to cache data so UI is super fast
‚úîÔ∏è A replacement for API calls made using fetch/axios (but for GraphQL)
how lazy loding works 
Lazy loading means we don‚Äôt load the entire application bundle upfront. Instead, we load specific components only when they‚Äôre needed.
In JavaScript, this is done using dynamic imports (import()), which allows the bundler to split the code into separate chunks.
 When the user reaches that part of the UI, the browser fetches the chunk asynchronously.
React.lazy uses this mechanism with Suspense to pause rendering until the chunk arrives.
Next.js dynamic() builds on this by adding SSR control, loading fallbacks, and automatic chunk optimization.

Server-Side Rendering (SSR)
Definition:
Server-Side Rendering is a method where the page HTML is generated on the server for every incoming request.
How it works:
User request ‚Üí Server fetches data ‚Üí Server generates HTML ‚Üí Browser receives ready page.
Static Site Generation (SSG)
Definition:
Static Site Generation is a method where pages are pre-rendered at build time and served as static HTML files.
How it works:
Build time ‚Üí Data fetched ‚Üí Static HTML generated ‚Üí Served via CDN.
Incremental Static Regeneration (ISR)
Definition:
ISR allows static pages to be regenerated in the background after a specified time interval without rebuilding the entire application.
4Ô∏è‚É£ Client-Side Rendering (CSR)
Definition:
Client-Side Rendering is when the browser loads minimal HTML and renders content using JavaScript after fetching data from APIs.
How it works
Browser loads JS ‚Üí API call ‚Üí Data fetched ‚Üí Page rendered.
6Ô∏è‚É£ Streaming
Definition:
Streaming allows parts of a page to be sent to the browser progressively instead of waiting for the entire page to be ready.
Hybrid Rendering
One of the most powerful features of Next.js is that it allows hybrid rendering.
Different pages in the same application can use different rendering methods depending on business needs.
Pages Router:

Uses getServerSideProps and getStaticProps

Traditional Next.js approach

App Router (Next.js 13+):

Uses React Server Components by default

Supports Streaming

Supports nested layouts

More modern architecture