
Next.js is a React-based framework for building full-stack web applications with features like:
Server-side rendering
Static site generation
API routes
File-based routing
Image optimization
Middleware
Incremental static regeneration (ISR)
Built-in support for SEO


key features of next
Server-Side Rendering (SSR):   Next.js enables server-side rendering out of the box. This means that pages 
can be pre-rendered on the server before being sent to the client. SSR improves initial page load performance 
and enables search engines to crawl and index the content effectively. It also provides a better experience for 
users with slower internet connections.

File-based Routing: Next.js introduces a file-based routing system. You can create a new file under the pages
 directory,and Next.js will automatically map it to a corresponding route. 

 Static Site Generation (SSG): Next.js supports static site generation, allowing you to pre-render entire pages 
 at build time. This is useful for content that doesn't frequently change, such as blog posts or documentation.
  With SSG, you can generate HTML files for each page in advance, resulting in faster page loads and better SEO
   performance.

Built-in CSS Support: Next.js provides built-in support for styling components using CSS. 

when should i call api in getServerSideProps

You should call an API inside the getServerSideProps function in Next.js when you need to fetch data that is 
specific to each request and cannot be pre-rendered at build time. Here are some scenarios where using 
getServerSideProps for API calls is appropriate:

Dynamic Data: If the data you need to fetch depends on dynamic parameters or user-specific information 
(e.g., user authentication, session data, or query parameters), getServerSideProps allows you to fetch the data
 dynamically on each request.

Personalized Content: When you have content that needs to be personalized for each user, such as user-specific 
dashboard information or personalized recommendations, getServerSideProps can fetch the necessary data based on 
the user's session or authentication information.

Real-Time Data: If you have data that frequently changes and needs to be up-to-date for each request, 
getServerSideProps enables you to fetch the latest data from an API on the server-side, ensuring that the rendered 
page always reflects the most recent information.

Data with Server-Side Logic: Sometimes, you may need to perform server-side calculations, transformations, 
or business logic before rendering the page. getServerSideProps allows you to fetch the required data and process 
it on the server before rendering the page.

Not calling an API in getServerSideProps can be suitable for cases where:

The data is not required for the initial page load and can be fetched asynchronously on the client-side after the page has rendered.

The data is not essential for search engine optimization (SEO) or doesn't need to be pre-rendered for better performance or content visibility.

You want to offload the API call from the server-side rendering process to reduce server load or minimize the time needed to generate the initial page.


import React from 'react';

function HomePage({ serverRenderedData }) {
  return (
      <p>Server-rendered data: {serverRenderedData}</p>
  );
}

export async function getServerSideProps() {
  // Call an API to fetch data
  const response = await fetch('https://api.example.com/data');
  const data = await response.json();

  // Extract the relevant data from the API response
  const serverRenderedData = data.someKey;

  // Return the data as props
  return {
    props: {
      serverRenderedData
    }
  };
}

export default HomePage;

const AboutUsComponent = dynamic(() => import('../../Container/AboutUS'), {
  suspense: true,
});

Dynamic importing in Next.js allows you to import components or modules dynamically at runtime, instead of
 including them in the initial bundle. This can help reduce the bundle size and improve performance by loading the
  necessary code only when it's actually needed.

  suspense: true, :This enables the usage of Suspense to handle the loading state while the component is being loaded
  providing a better user experience during the component loading process.

  
next js supports file based routing 

   server coponent : a component which execute on server its fater and best for seo on server side ui is coming 
   from server 
   clent component : a component which excecute on browser on client 

   on compolex application we should use next js  
    default type of componet is sever component
     
     if we want to create client component we have to use "use client" on number one line other wise we get error
     # we cant use events in server components like onclick 

     why server component better for seo 
     serch engine can easily read page content from server rendering

     #there are two tehniques 
     for pre rendering 
     1 static side genration and  serverside randerig ehich we can do with getStaticProps() and getserverSideprops()

     through both these we can pre rander pages which means our html our data will go to client randered
     before hand  
    
getstaticpath=>specify  dynamic route to pre rander pages 
     getStaticPaths must be used with getStaticProps
You cannot use getStaticPaths with getServerSideProps

lasy loding in react
import React, { Suspense } from 'react';
const LazyComponent = React.lazy(() => import('./LazyComponent'));
function MyComponent() {
  return (
    <Suspense fallback={<div>Loading...</div>}>
      <LazyComponent />
    </Suspense>
  );
}

//next 
const ContactUs = dynamic(() => import('../../Container/ContactUs'), {
  suspense: true,
  loading: () => <p>Loading...</p>,
});
//promis
const myPromise = new Promise((resolve, reject) => {
  // Asynchronous operation
  setTimeout(() => {
    // If the operation is successful, call resolve
    resolve('Operation completed successfully');

    // If there's an error, call reject
    // reject('Operation failed');
  }, 2000);
});
then(onFulfilled, onRejected): Attaches callbacks for handling the fulfillment or rejection of the Promise.
catch(onRejected): Attaches a callback to handle the rejection of the Promise. It's equivalent to .then(null, onRejected).
finally(onFinally): Attaches a callback to execute regardless of whether the Promise is fulfilled or rejected. It's useful for cleanup operations.
Promise.resolve(value): Creates a resolved Promise with the specified value.
Promise.reject(reason): Creates a rejected Promise with the specified reason.
Promise.all(iterable): Returns a single Promise that resolves when all of the promises in the iterable argument have resolved or when the iterable contains no promises.
Promise.race(iterable): Returns a Promise that resolves or rejects as soon as one of the promises in the iterable resolves or rejects, with the value or reason from that promise.
states of promis
 Pending: Initial state, neither fulfilled nor rejected.
Fulfilled: The operation completed successfully.
Rejected: The operation failed

ISR ‚Äî Incremental Static Regeneration
ISR allows you to statically generate pages at build time and update them incrementally after deployment without rebuilding the entire site.
How It Works:
You define a revalidate period (in seconds) in your getStaticProps().

After the first request, a background regeneration is triggered if the page is older than the revalidation time.
export async function getStaticProps() {
  const data = await fetchData();
  return {
    props: { data },
    revalidate: 60, // Regenerate this page every 60 seconds
  };
}
Use Cases:
Blog posts
Product listings
Marketing pages with frequent updates
Pages where data changes, but not per user

üü¢ Pros:
Fast page loads (served from CDN)
Always up-to-date (after a small delay)
No rebuilds needed for content changes

CSR ‚Äî Client-Side Rendering
CSR renders content entirely in the browser after the page loads, typically using useEffect or other hooks to fetch data.
Goal	Choose
Fast, SEO-friendly page	ISR
Authenticated dashboard	CSR
Blog that updates weekly	ISR
Live analytics dashboard	csr

The /pages directory is the traditional file-based routing system in Next.js (before version 13). It maps files to routes automatically.
File-based routing
Pre-rendering using:
getStaticProps (SSG)

getServerSideProps (SSR)

getStaticPaths (for dynamic SSG routes)

Client-side navigation with next/link and next/router

API routes via pages/api/
Limitations
Difficult to manage layouts
No support for server components
Less control over rendering granularity
Lacks streaming and nested routing

The /app directory is a new, more powerful routing system based on React Server Components and layouts. It enables more advanced use cases.
Built on React Server Components (RSC)
Supports:
Nested layouts
Streaming (<Suspense>)
Server & client components
Loading & error UI
Built-in support for metadata (SEO)
/app
  layout.tsx              ‚Üí Defines root layout
  page.tsx                ‚Üí Home: '/'
  about/page.tsx          ‚Üí '/about'
  blog/[slug]/page.tsx    ‚Üí '/blog/my-post'
  blog/[slug]/loading.tsx ‚Üí Loading UI
  blog/[slug]/error.tsx   ‚Üí Error boundary

  Server-first by default (better performance)
Layouts that persist across routes
Advanced routing: parallel routes, intercepting routes
Built-in loading.tsx and error.tsx support
Streaming: only send what‚Äôs needed
What Is "Layout Support" in Next.js?
A layout is a common UI wrapper shared across multiple pages of your application ‚Äî for example:
A navbar,A footer,A sidebar,Shared CSS styles,Authentication wrapper
Instead of repeating that code on every page, a layout lets you define it once and reuse it across pages.
/app
  layout.tsx           ‚Üê Main layout (header/footer)
/app/dashboard
  layout.tsx           ‚Üê Dashboard-specific layout (sidebar)
/app/dashboard/page.tsx ‚Üê Dashboard page content
Each layout.tsx wraps only the routes below it. That means:

You can have nested layouts (e.g., a sidebar only on the dashboard)

Layouts persist across route changes without re-rendering

Layouts can be server or client components
In the old /pages directory (Pages Router), you used:

Function	Purpose
getStaticProps	Static Site Generation (SSG)
getServerSideProps	Server-Side Rendering (SSR)
getStaticPaths	Required for dynamic SSG routes with params
But in the new /app directory (App Router), these are replaced with React Server Components and fetch() caching strategies.
Old Pages Router	New App Router Replacement
getStaticProps	fetch() with { cache: 'force-cache' }
getServerSideProps	fetch() with { cache: 'no-store' }
getStaticPaths	generateStaticParams() function


