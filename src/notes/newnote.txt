Event bubbling is a concept in the DOM (Document Object Model) where an event starts from the deepest (target) element and bubbles up to its parent elements.

<div id="parent">
  <button id="child">Click Me</button>
</div>
document.getElementById('parent').addEventListener('click', () => {
  console.log('Parent clicked!');
});
document.getElementById('child').addEventListener('click', () => {
  console.log('Child clicked!');
});
üëá What Happens When You Click the Button:
Output:
Child clicked!
Parent clicked!
Good for event delegation: handling multiple children with one event listener.
event.stopPropagation();
event.stopPropagation() is used to stop an event from bubbling up the DOM tree.
 Default Behavior (Without stopPropagation())
When you click a child element, the event bubbles up ‚Äî meaning both the child and parent handlers are triggered.
document.getElementById('child').addEventListener('click', (event) => {
  event.stopPropagation(); // Stops bubbling here
  console.log('Child clicked');
});
output Child clicked

Event Delegation is a technique where you attach a single event listener to a parent element, and then use that to handle events on its
 child elements ‚Äî even if those children are added later.
Why Use Event Delegation?
‚úÖ Performance: Fewer event listeners, especially with many elements (e.g., 100 buttons).
‚úÖ Dynamic Elements: It works for elements added after the page loads.
‚úÖ Cleaner Code: Centralizes logic instead of attaching to every child.
<ul id="menu">
  <li>Home</li>
  <li>About</li>
  <li>Contact</li>
</ul>
Instead of adding click listeners to each <li>, delegate using the parent:
document.getElementById("menu").addEventListener("click", function (event) {
  if (event.target.tagName === "LI") {
    console.log("You clicked:", event.target.textContent);
  }
});
output You clicked: About

debouncing ‚Äì Delay execution until user stops triggering
Throttling ‚Äì Run at most once per interval
function throttle(func, limit) {
  let lastCall = 0;
  return function (...args) {
    const now = Date.now();
    if (now - lastCall >= limit) {
      lastCall = now;
      func.apply(this, args);
    }
  };
}

 const handleResize = throttle(() => {
    setWindowSize({
      width: window.innerWidth,
      height: window.innerHeight,
    });
  }, 500); // Runs only once every 500ms

window.addEventListener("scroll", throttle(() => {
  console.log("Scroll event fired");
}, 1000));
Even if you scroll continuously, it logs at most once every 1000ms

A Promise is a placeholder for a future value ‚Äî something that may:‚úÖ Succeed (fulfilled) ‚ùå Fail (rejected) ‚è≥ Or is still pending
promise.then((result) => { // then() ‚Äì handle success
  console.log(result);
});
promise// error
  .then((result) => console.log(result))
  .catch((error) => console.log(error));
 finally() ‚Äì always runs (success or error)
 promise
  .then((res) => console.log(res))
  .catch((err) => console.log(err))
  .finally(() => console.log("Done!"));
  //real exmpl
const fetchData = () => {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      const success = true;
      success ? resolve("Data loaded") : reject("Failed to load");
    }, 1000);
  });
};

fetchData()
  .then((data) => console.log("‚úÖ", data))
  .catch((err) => console.log("‚ùå", err))
  .finally(() => console.log("‚úÖ Always runs"));

 Promise.resolve(value)
Returns a resolved promise:
Promise.resolve("Hi").then(console.log); // "Hi"

Returns a rejected promise:
Promise.reject("Oops").catch(console.log); // "Oops"

Promise.all====Waits for all promises to resolve, or rejects if one fails.
Promise.all([
  Promise.resolve(1),
  Promise.resolve(2),
  Promise.resolve(3),
]).then(console.log);

4. Promise.race([...])
Returns first resolved or rejected promise.
Promise.race([
  Promise.resolve("Fast"),
  new Promise((res) => setTimeout(() => res("Slow"), 1000)),
]).then(console.log); // "Fast"

Promise.allSettled([...])
Waits for all to finish, returns array with status (fulfilled/rejected).
Promise.allSettled([
  Promise.resolve("Done"),
  Promise.reject("Error"),
]).then(console.log);

 Promise.any([...])
Returns first fulfilled, ignores rejections. If all reject ‚Üí throws error.
Promise.any([
  Promise.reject("Err 1"),
  Promise.resolve("First success"),
  Promise.reject("Err 2"),
]).then(console.log); // "First success"

A Generator Function is a special kind of function in JavaScript that can pause and resume 
 execution It uses the function* syntax and the yield keyword to produce values one at a time ‚Äî like a factory that builds values on demand.

function* numberGen() {
  let i = 1;
  while (true) {
    yield i++;
  }
}
const gen = numberGen();
console.log(gen.next().value); // 1
console.log(gen.next().value); // 2
console.log(gen.next().value); // 3
function* myGenerator() {
  console.log("Started");
  yield 1; // Pause here
  console.log("Resumed");
  yield 2; // Pause again
  console.log("Done");
}
const gen = myGenerator(); // Just creates the generator (nothing runs yet)

console.log(gen.next()); // { value: 1, done: false }
// Console: Started

console.log(gen.next()); // { value: 2, done: false }
// Console: Resumed

console.log(gen.next()); // { value: undefined, done: true }
// Console: Done
In JavaScript, you can abruptly stop a generator function using the return() or throw() methods provided by the Generator object. These methods allow you to exit or interrupt the generator manually.
. Stop using .return()
The .return(value) method immediately ends the generator and returns the value you provide.

. Interrupt with .throw()
The .throw(error) method throws an error inside the generator ‚Äî like injecting an exception. You can catch it inside the generator with try/catch.

A Proxy in JavaScript is an object that allows you to intercept and customize operations performed on another object, such as:
Getting a property
Setting a property
Deleting a property
Checking if a property exists
Think of it as a middleman between your code and the actual object. syntx const proxy = new Proxy(target, handler);
target: the original objectt
handler: an object that defines traps (functions that intercept operations).
aN stands for "Not-a-Number".
It is a special value in JavaScript that represents the result of an operation that does not produce a valid number ‚Äî even though the operation expects a number.
 When Does NaN Occur?
NaN shows up in operations where:
You do a math operation on non-numeric values
You parse invalid numbers
You divide 0/0
let result1 = "abc" / 2;         // NaN (invalid division)
let result2 = parseInt("xyz");   // NaN (can't convert to number)
let result3 = Math.sqrt(-1);     // NaN (no real square root)
console.log(result1, result2, result3); // NaN NaN NaN
ndefined	A variable has been declared but not assigned a value yet
let a;
console.log(a);         // undefined (not assigned)
null	A variable has been explicitly assigned to represent no value
et b = null;
console.log(b);         // null (explicitly nothing)
 A function that takes another function as an argument, or returns a function. map and filtter is HOF Because filter() and map() take callback functions as parameters.
 EXPLA HOC 
 function withLoader(Component) {
  return function WithLoaderComponent({ isLoading, ...props }) {
    if (isLoading) return <div>Loading...</div>;
    return <Component {...props} />;
  };
}

const Profile = ({ name }) => <div>Welcome, {name}</div>;
const ProfileWithLoader = withLoader(Profile);

// Usage
<ProfileWithLoader isLoading={false} name="Anjali" />
| Feature                | Redux                                          | React Context                                   |
| ---------------------- | ---------------------------------------------- | ----------------------------------------------- |
| **Purpose**            | State management library for complex apps      | Pass data deeply without prop drilling          |
| **Boilerplate**        | More setup and code (actions, reducers, store) | Minimal setup, built-in with React              |
| **Performance**        | Better for large, frequent updates (optimized) | Can cause unnecessary re-renders if not careful |
| **DevTools**           | Excellent devtools, time-travel debugging      | Basic React devtools, no time travel            |
| **Middleware support** | Supports middleware like redux-thunk, saga     | No middleware, just basic state passing         |
| **Learning curve**     | Steeper, more concepts to learn                | Easier for small apps                           |
| **Use case**           | Large-scale apps with complex state logic      | Small to medium apps or simple shared state     |
| **Community**          | Huge ecosystem and community                   | Part of React, no external dependency           |

When to Use Redux
Complex state with many actions and reducers
Need for middleware (async flows, logging)
Large apps with many components relying on state
You want powerful devtools and debugging features
When to Use React Context
Simple or medium apps
Sharing state like theme, locale, auth info
Avoid adding extra dependencies
You want quick and easy state sharing

HOW TO Connect componet with store in redux
. Using React-Redux Hooks (Recommended for functional components)
Since React-Redux v7.1+, you can use hooks for a cleaner approach.
useSelector ‚Äî to read state from the store.
useDispatch ‚Äî to dispatch actions.

What is Middleware in Redux?
Middleware is a piece of code that sits between the action dispatch and the reducer in Redux. It intercepts every action sent to the store and can:
 Why Use Middleware?
To handle asynchronous logic (e.g., API calls)
To log actions for debugging
To modify or cancel actions
To integrate with other libraries (analytics, crash reporting)
middleware
redux-thunk ‚Äî lets you write async logic that dispatches actions
redux-saga ‚Äî more advanced async side effect manager using generators
logger ‚Äî logs every action and state change

Common Ways to Access Child State in Parent
 Lifting State Up
The most React-idiomatic way is to move the state from the child to the parent, then pass it down as props.
function Parent() {
  const [childData, setChildData] = React.useState('');

  return (
    <Child value={childData} onChange={setChildData} />
  );
}
function Child({ value, onChange }) {
  return (
    <input
      value={value}
      onChange={e => onChange(e.target.value)}
    />
  );
}
 Using Refs with forwardRef and useImperativeHandle
If you must keep state inside the child, you can expose some methods to the parent via refs.
const Child = React.forwardRef((props, ref) => {
  const [count, setCount] = React.useState(0);

  React.useImperativeHandle(ref, () => ({
    getCount: () => count,
  }));

  return <button onClick={() => setCount(c => c + 1)}>Count: {count}</button>;
});

function Parent() {
  const childRef = React.useRef();

  const showCount = () => {
    alert(childRef.current.getCount());
  };

  return (
    <>
      <Child ref={childRef} />
      <button onClick={showCount}>Show Child Count</button>
    </>
  );
}
Wrap functional components with React.memo() to memoize the component and prevent re-renders unless props change.
 React Rendering ‚Äì In Short
Initial Render:
React builds a virtual DOM from your JSX and mounts it to the real DOM.
State/Props Change
If you update state or receive new props, React re-renders the component.
Re-render Process:
React calls the component function again to get new JSX.
It compares the new virtual DOM with the old one (diffing).
Only the changed parts are updated in the real DOM.
Commit Phase:
React updates the actual DOM.
Then runs useEffect or useLayoutEffect.

 How Many Times Does a Component Re-render When You Set State Multiple Times in One Go?
üëâ Answer:
If multiple setState calls happen synchronously in a single function (like an event handler), React batches them and re-renders only once.
function Counter() {
  const [count, setCount] = useState(0);

  const handleClick = () => {
    setCount(prev => prev + 1);
    setCount(prev => prev + 1);
    setCount(prev => prev + 1);
  };

  return (
    <div>
      <p>{count}</p>
      <button onClick={handleClick}>+3</button>
    </div>
  );
}

Even though setCount is called 3 times, React batches the updates.
count updates once, final value becomes count + 3.
Component re-renders only once after all 3 updates.

In React, component names are created with capital letters by convention and for a specific technical reason related to how React
 distinguishes between HTML elements and custom components.
<MyCompo/>: React treats anything starting with a capital letter (MyComponent) as a custom React component.
<myCompo/> : React treats it as a regular HTML element, like <div> or <span>, and tries to render it directly in the DOM.
What is break in JavaScript?

The break statement stops the execution of a loop (or switch case) immediately and jumps out of the loop.
It is commonly used when you want to exit the loop based on a certain condition.
ex Let‚Äôs say we want to search for the number 5 in an array, and once we find it, we stop iterating.
const numbers = [1, 2, 3, 4, 5, 6, 7, 8];
for (let i = 0; i < numbers.length; i++) {
  console.log('Checking number:', numbers[i]);
  if (numbers[i] === 5) {
    console.log('Number 5 found! Stopping the loop.');
    break;  // Stop looping once we find 5
  }
}

Apollo Client is a JavaScript library that helps your frontend app interact with a GraphQL server easily.
It‚Äôs like a bridge between your React app and your GraphQL API. you can cache api data with the help of apollo client

Instead of having multiple REST endpoints, GraphQL lets you ask for exactly what you need, from a single endpoint.

in react ‚Ä¢ Render optimization & avoiding unnecessary re-renders
Why Re-renders Happen in React
Inline functions & objects in JSX
Parent component re-rendering frequently
Large component trees
Improper use of Context
solution
#React.memo ‚Äì Memoizing Components
Prevents re-render if props haven‚Äôt changed.
#useCallback ‚Äì Memoizing Functions
Avoids creating new function references on every render.
#useMemo ‚Äì Memoizing Expensive Calculations
Prevents expensive computations on every render.
6Ô∏è‚É£ Avoid Inline Objects & Arrays
Each render creates a new reference.
7Ô∏è‚É£ Key Prop Optimization (Lists)
Wrong keys cause re-render & DOM mismatch.
8Ô∏è‚É£ State Colocation (Very Important)
Keep state as close as possible to where it‚Äôs used.

in react ‚Ä¢ List virtualization
‚ÄúList virtualization improves performance by rendering only visible list items. I commonly use react-window(npm install react-window) to efficiently handle large datasets like tables or chat messages.‚Äù
when NOT to Use Virtualization
Small lists (<100 items) ,SEO-critical content ,Print layouts
Initial load
Only items visible in the viewport are rendered
Example: 10‚Äì15 rows When you scroll
Items going out of view are unmounted
New items coming into view are rendered

What is Zustand?

Answer:
Zustand is a lightweight state management library for React that allows managing global client-side state with minimal boilerplate and optimized re-renders.
Why use Zustand instead of useState or Context?
Avoids prop drilling
Better performance than Context
No Provider required
Easier to scale than useState
Zustand stores are independent and don‚Äôt need a Provider.
Zustand is best for client/UI state like auth, theme, cart, filters, and UI preferences.
5Ô∏è‚É£ Is Zustand a replacement for Redux?
Not completely. Zustand replaces Redux for most client-state use cases, but Redux may still be used for very complex workflows.
How does Zustand prevent unnecessary re-renders?
By using selectors. Components re-render only when the selected slice of state changes. const count = useStore(state => state.count);
selector in Zustand :A selector is a function that selects a specific part of the store, helping improve performance by reducing re-renders.
update state in Zustand?: Using the set function. : set(state => ({ count: state.count + 1 }));
Zustand handle async actions? Yes. Async logic can be written directly inside store actions.
fetchUser: async () => {
  const res = await fetch("/user");
  set({ user: await res.json() });
}
How do you split stores in Zustand?By creating multiple stores (authStore, cartStore, uiStore) for better modularity.
How does Zustand compare to Context API?
Zustand offers fine-grained re-render control, whereas Context re-renders all consumers on value change.
How do you persist Zustand state? Using the persist middleware.:persist((set) => ({ theme: "dark" }), { name: "theme" })
How do you integrate Zustand with React Query?
Use React Query for server state and Zustand for client state like auth tokens or UI flags.
Zustand middleware :Middlewares enhance stores (persist, devtools, subscribeWithSelector).
How do you subscribe to state changes without re-render?: useStore.subscribe
How does Zustand work internally?
It uses a central store with a subscription model, notifying only components whose selected state changes.
Can Zustand work outside React?:Yes. Zustand stores are plain JavaScript and can be used outside React.
How do you reset Zustand store?:set({ count: 0 });
When would you NOT use Zustand?
For server-side data fetching
For small, local component state
When React Query is more suitable

‚ÄúZustand is a lightweight, flexible state library best for client-side UI state, while Redux 
is a more structured and opinionated solution suitable for large-scale applications with complex logic.‚Äù
Can we use both together? A: Yes. Many apps use Zustand for UI state and Redux or React Query for server data.

‚ÄúFirebase and Supabase are Backend-as-a-Service platforms. Firebase uses NoSQL and excels at realtime features, while Supabase is an open-source Firebase alternative built on PostgreSQL, better suited for relational data and scalable applications.‚Äù
üëâ They let frontend developers build full-stack apps without managing servers.
üîπ Core Firebase Services

Authentication ‚Äì Email, Google, GitHub, OTP
Firestore ‚Äì NoSQL document database
Realtime Database ‚Äì Live data sync
Cloud Functions ‚Äì Serverless backend logic
Storage ‚Äì File uploads
Hosting ‚Äì Static hosting
Analytics & Crashlytics


redux saga l;;;;;;;========https://chatgpt.com/share/6964f45e-2dcc-8012-b826-b09d4ad87fc4

flux :Flux is an application architecture (pattern) for managing state in React apps. It‚Äôs not a library by
 itself‚Äîit‚Äôs a concept introduced by Facebook to solve problems with complex state updates.
 Flux defines how data flows in your React application.
üëâ One-way (unidirectional) data flow
Action ‚Üí Dispatcher ‚Üí Store ‚Üí View (React Component)
Why Flux was introduced (Problem it solves)
Before Flux:
State was shared between many components
Components updated each other directly
Apps became hard to debug
Bugs caused unpredictable UI updates
===Flux solves this by:
Making state updates predictable
Having a single direction of data flow
Centralizing app state in Stores
Do We Need to Download Flux?
üîπ Short Answer: No (usually) flux is a pattern, not reqanduired to install.
Yes ‚úÖ Redux is based on Flux,